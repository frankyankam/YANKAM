library(YANKAM)
library(YANKAM)
library(YANKAM)
?gradient_conjugue
library(YANKAM))
library(YANKAM)
?gradient_conjugue
gradient_conjugue <- function(A, b, x0, tol, max_iter) {
n <- length(x0)
x <- x0
r <- b - A %*% x
p <- r
for (k in 1:max_iter) {
alpha <- sum(r * r) / sum(p * (A %*% p))
x <- x + alpha * p
r_prev <- r
r <- r - alpha * (A %*% p)
beta <- sum(r * r) / sum(r_prev * r_prev)
p <- r + beta * p
if (sqrt(sum(r * r)) < tol) {
break
}
}
return(x)
}
A <- matrix(c(4, 1, 1, 3), nrow = 2)
b <- c(1, 2,4)
x0 <- c(0, 0,7)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A, b, x0, tol, maxiter)
x0 <- c(0, 0,0)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A, b, x0, tol, maxiter)
A <- matrix(c(4, 1, 1, 3,4,7,7,5,2), nrow = 3)
b <- c(1, 2,4)
x0 <- c(0, 0,0)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A, b, x0, tol, maxiter)
plot(gradient_conjugue())
plot(gradient_conjugue(A,b,x0,tol,maxiter))
library(ggplot2)
for (k in 1:max_iter) {
alpha <- sum(r * r) / sum(p * (A %*% p))
x <- x + alpha * p
r_prev <- r
r <- r - alpha * (A %*% p)
beta <- sum(r * r) / sum(r_prev * r_prev)
p <- r + beta * p
if (sqrt(sum(r * r)) < tol) {
break
}
}
A <- matrix(c(4, 1, 1, 3,4,7,7,5,2), nrow = 3)
b <- c(1, 2,4)
x0 <- c(0, 0,0)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A, b, x0, tol, maxiter)
library(YANKAM)
gradient_conjugue(A, b, x0, tol, maxiter)
ggplot(gradient_conjugue,aes(x))+geom_point()
ggplot(gradient_conjugue,aes(x,x0))+geom_point()
ggplot(data=gradient_conjugue,aes(x,x0))+geom_point()
ggplot(data=gradient_conjugue,aes(x=x,y=x0))+geom_point()
ggplot(data=gradient_conjugue)+geom_point()
ggplot(data=gradient_conjugue,aes(x,maxiter))+geom_point()
ggplot(data="gradient_conjugue",aes(x,maxiter))+geom_point()
ggplot(aes(x,maxiter))+geom_point()
gradient_conjugue(A, b, x0, tol, maxiter)+ggplot(aes(x,maxiter))+geom_point()
install.packages("numDeriv")
source("C:/Users/brice/OneDrive/Bureau/Course Files - Introduction to R/YANKAM/R/gradconj.R")
library(YANKAM)
?gradient
# Retourner le gradient
return(grad)
# Calculer les dérivées partielles de f par rapport à chaque variable xi
df_dx <- sapply(seq_along(x), function(i) {
D(f, paste0("x", i))
})
gradient <- function(f, x) {
# Calculer les dérivées partielles de f par rapport à chaque variable xi
df_dx <- sapply(seq_along(x), function(i) {
D(f, paste0("x", i))
})
# Calculer le gradient de f
grad <- df_dx(x)
# Retourner le gradient
return(grad)
}
f <- x1.x2+x2.x1
f <- paste(c("x"),(1,2))
f <- paste(c("x"),c(1,2))
f
f <-"x1.x2"+"x2.x1"
library(YANKAM)
?gradient
gradient <- function(f, x) {
# Calculer les dérivées partielles de f par rapport à chaque variable xi
df_dx <- sapply(seq_along(x), function(i) {
D(f, paste0("x", i))
})
# Calculer le gradient de f
grad <- df_dx(x)
# Retourner le gradient
return(grad)
}
f <- function(x) {
return(x[1]^2 + x[2]^2+3*x[2]+2*x[1]) }
x <- c(1, 1)
gradient <- function(f, x)
x <- c(1, 1)
gradient(f,x)
grad
print(gradient)
print(gradient(f,x))
library(YANKAM)
?hessian
library(numDeriv)
# Define a function of n variables
f <- function(x) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
return(x1^2 + x2^3 + x3^4)
}
# Compute the gradient of f
grad(f, x = c(1, 2, 3))
grad <- function(f, x) {
n <- length(x)
grad <- numeric(n)
h <- 1e-4
for (i in 1:n) {
e <- numeric(n)
e[i] <- h
grad[i] <- (f(x + e) - f(x - e)) / (2 * h)
}
return(grad)
}
f <- function(x) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
return(c(2 * x1, 3 * x2^2, 4 * x3^3))
}
grad(f, x = c(1, 2, 3))
library(YANKAM)
?grad
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
#' calcul du gradient
#'
#' @param f fonction a n variable
#' @param x vecteur numerique de longueur n
#' @importFrom numDeriv
#'
#' @return  gradient de f
#' @examples
#'  f <- function(x) {
#'   x1 <- x[1]
#'   x2 <- x[2]
#'   x3 <- x[3]
#'   return(c(2 * x1, 3 * x2^2, 4 * x3^3))
#' }
#'  grad(f, x = c(1, 2, 3))
#' @export
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
?grad
library(YANKAM)
?gradient
f <- function(x) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
return(c(2 * x1, 3 * x2^2, 4 * x3^3))
}
grad(f, x = c(1, 1, 1))
grad(f, x = c(1, 1, 1),h=0.1)
grad(f, x = c(1, 1, 1),h=0.001)
grad(f, x = c(1, 1))
grad(f, x = c(1, 1,0))
grad(f, x = c(0, 0,0))
grad(f, x = c(1, 2,3))
library(YANKAM)
?gradient
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
f <- function(x1, x2) {
x1^2 - x1*x2 + x2^2 - 3*x2
}
f
gradient(f,x)
gradient(f,x=c(1,2))
gradient(f,x=c(X1=1,X2=2))
f
gradient(f,(x1,x2)=c(1,2))
gradient(f,(x1 x2)=c(1,2))
gradient(f,(x1, x2)=c(1,2))
gradient(f,(x1:x2)=c(1,2))
gradient(f,(x1,x2)==c(1,2))
gradient(f,x=c(length(2)))
grad(f)
#' calcul du gradient
#'
#' @param f fonction a n variable
#' @param x vecteur numerique de longueur n
#' @importFrom numDeriv
#'
#' @return  gradient de f
#' @examples
#'  f <- function(x) {
#'   x1 <- x[1]
#'   x2 <- x[2]
#'   x3 <- x[3]
#'   return(c(2 * x1, 3 * x2^2, 4 * x3^3))
#' }
#'  gradient(f, x = c(1, 2, 3))
#' @export
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
f <- function(x1, x2) {
x1^2 - x1*x2 + x2^2 - 3*x2
}
gradient(f,x= c(1,2))
gradient(f,x= c(1,2))
gradient(f,x1,x2= c(1,2))
gradient(f,(x1+x2)= c(1,2))
gradient(f,(x1.x2)= c(1,2))
gradient(f,(x1 x2)= c(1,2))
hessian(f,(x1,x2)= c(1,2))
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
f <- function(x1, x2) {
x1^2 - x1*x2 + x2^2 - 3*x2
}
gradient(f,c(0,0))
f <- function(x1, x2) {
x[1]^2 - x[1]*x[2] + x[2]^2 - 3*x[2]
}
gradient(f,c(0,0))
gradient(f,x=c(0,0))
gradient(f,x=c(1,2))
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
f <- function(x1, x2) {
x[1]^2 - x[1]*x[2] + x[2]^2 - 3*x[2]
}
gradient(f,x=c(1,2))
#' Cette fonction calcule le gradient d'une fonction à n variables.
#'
#' @param f La fonction à dériver.
#' @param x Le vecteur de variables.
#' @return Le gradient de la fonction.
#'
#' @examples
#' gradient(function(x) sum(x^2), c(1, 2, 3))
#'
#' @export
gradient <- function(f, x) {
numDeriv::grad(f, x)
}
gradient(function(x) sum(x^2), c(1, 2, 3))
gradient(function(x) sum(x^2), c(1, 1, 1))
library(YANKAM)
?gradient
f <- function(x) {
x[1]^2 - x[1]*x[2] + x[2]^2 - 3*x[2]
}
gradient(f,x=c(1,2))
gradient(f,x=c(1,1))
gradient(f,x=c(1,1,nrow(2)))
gradient(f,x=c(1,1,nrow(2),ncol(2)))
gradient(f,x=c(0,0))
gradient(f,x=c(1,c(1,2)))
hessian <- function(f, x) {
n <- length(x)
H <- matrix(0, n, n)
h <- 1e-4
for (i in 1:n) {
for (j in i:n) {
H[i,j] <- (f(c(x[i]+h, x[j]+h)) - f(c(x[i]+h, x[j]-h)) - f(c(x[i]-h, x[j]+h)) + f(c(x[i]-h, x[j]-h))) / (4*h^2)
H[j,i] <- H[i,j]
}
}
return(H)
}
hessian(f,x=c(1,2))
hessian(f,x=c(0,0))
f
hessian(f,x=c(1,0))
hessian(1,1)
hess <- function(f, x) {
n <- length(x)
H <- matrix(0, n, n)
h <- 1e-4
for (i in 1:n) {
for (j in i:n) {
H[i,j] <- (f(c(x[i]+h, x[j]+h)) - f(c(x[i]+h, x[j]-h)) - f(c(x[i]-h, x[j]+h)) + f(c(x[i]-h, x[j]-h))) / (4*h^2)
H[j,i] <- H[i,j]
}
}
return(H)
}f <- function(x) {
hess <- function(f, x) {
n <- length(x)
H <- matrix(0, n, n)
h <- 1e-4
for (i in 1:n) {
for (j in i:n) {
H[i,j] <- (f(c(x[i]+h, x[j]+h)) - f(c(x[i]+h, x[j]-h)) - f(c(x[i]-h, x[j]+h)) + f(c(x[i]-h, x[j]-h))) / (4*h^2)
H[j,i] <- H[i,j]
}
}
return(H)
}
f <- function(x) {
x[1]^2 - x[1]*x[2] + x[2]^2 - 3*x[2]
}
hess(f,x=c(1,1))
hess(f,x=c(c(1,1),c(1,1))
hess(f,x=c(c(1,1),c(1,1)))
hess(f,x=c(c(1,1),c(1,1)))
hess(f,x=c(c(1,0),c(0,1)))
plot(x)
source("C:/Users/brice/OneDrive/Bureau/Course Files - Introduction to R/YANKAM/R/gradconj.R")
library(YANKAM)
?gradient
?gradient_conjugue
library(YANKAM)
library(YANKAM)
example(YANKAM)
example("gradient_conjugue")
example("gradient")
library(YANKAM)
example("YANKAM.Rproj")
example(YANKAM.Rproj)
ggplot(aes(x,x0,)+geom_point()
r_prev <- r
for (k in 1:max_iter) {
alpha <- sum(r * r) / sum(p * (A %*% p))
x <- x + alpha * p
ggplot(aes(x,x0,)+geom_point()
r_prev <- r
for (k in 1:max_iter) {
alpha <- sum(r * r) / sum(p * (A %*% p))
x <- x + alpha * p
ggplot(aes(x,x0,)+geom_point())
r_prev <- r
r <- r - alpha * (A %*% p)
beta <- sum(r * r) / sum(r_prev * r_prev)
p <- r + beta * p
if (sqrt(sum(r * r)) < tol) {
break
}
}
A <- matrix(c(4, 1, 1, 3), nrow = 2)
b <- c(1, 2)
x0 <- c(0, 0)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A, b, x0, tol, maxiter)
source("C:/Users/brice/OneDrive/Bureau/Course Files - Introduction to R/YANKAM/R/gradconj.R")
#'
#' @return    la solution de Ax=b
#' @examples
#'  A <- matrix(c(4, 1, 1, 3), nrow = 2)
#' b <- c(1, 2)
#' x0 <- c(0, 0)
#' tol <- 1e-10
#' maxiter <- 1000
#' gradient_conjugue(A, b, x0, tol, maxiter)
#' @export
gradient_conjugue <- function(A, b, x0, tol, max_iter) {
n <- length(x0)
x <- x0
r <- b - A %*% x
p <- r
for (k in 1:max_iter) {
alpha <- sum(r * r) / sum(p * (A %*% p))
x <- x + alpha * p
ggplot(aes(x,x0,color="blue")+geom_point())
r_prev <- r
r <- r - alpha * (A %*% p)
beta <- sum(r * r) / sum(r_prev * r_prev)
p <- r + beta * p
if (sqrt(sum(r * r)) < tol) {
break
}
}
return(x)
}
A <- matrix(c(4, 1, 1, 3), nrow = 2)
b <- c(1, 2)
x0 <- c(0, 0)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A, b, x0, tol, maxiter)
library(ggplot2)
gradient_conjugue(A, b, x0, tol, maxiter)
gradient_conjugue(A, b, x0, tol, maxiter)
gradient_conjugue(A, b, x0, tol, maxiter)
source("C:/Users/brice/OneDrive/Bureau/Course Files - Introduction to R/YANKAM/R/gradconj.R")
library(YANKAM)
?YANKAM
??YANKAM
?ggplot2
??ggplot2
example(ggplot2)
example("ggplot2")
A <- matrix(c(4,7,9,6,3,4,7,3,4),nrow = 3,ncol=3)
b <- c(4,2,3)
x0 <- c(1,1,1)
tol <- 1-10e
maxiter <- 1000
gradient_conjugue(A,b,x0,tol,maxiter)
tol <- 1e-10
maxiter <- 1000
gradient_conjugue(A,b,x0,tol,maxiter)
gradient_conjugue(A,b,x0,tol,maxiter)
tol <- 1e-6
maxiter <- 1000
gradient_conjugue(A,b,x0,tol,maxiter)
source("C:/Users/brice/OneDrive/Bureau/Course Files - Introduction to R/YANKAM/R/YANKAM.R", echo=TRUE)
source("C:/Users/brice/OneDrive/Bureau/Course Files - Introduction to R/YANKAM/R/gradconj.R")
library(YANKAM)
example(YANKAM)
A
B <- matrix
B <- matrix(c(4,2,8,6,1,2,3,4,6),nrow = 3,ncol=3)
j <- c(7,6,2)
x0 <- c(0,0,0)
tol <- 1e-10
maxiter
YANKAM(B,j,x0,tol,maxiter)
?YANKAM
#' Cette fonction calcule le gradient d'une fonction à n variables.
#'
#' @param f La fonction à dériver.
#' @param x Le vecteur de variables.
#' @return Le gradient de la fonction.
#'
#' @examples
#' gradient(function(x,y) sum(x^2,y), c(1, 2, 3))
#'
#' @export
gradient <- function(f, x,y) {
numDeriv::grad(f, x,y)
}
gradient(function(x,y) sum(x^2,y), c(1, 2, 3))
gradient(function(x,y) sum(x^2,y), c(1, 2, 3))
